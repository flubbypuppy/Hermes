'use strict';

var react = require('react');
var jsxRuntime = require('react/jsx-runtime');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var reservedModifierKeywords = ['ctrl', 'shift', 'alt', 'meta', 'mod'];
var mappedKeys = {
  esc: 'escape',
  "return": 'enter',
  left: 'arrowleft',
  up: 'arrowup',
  right: 'arrowright',
  down: 'arrowdown'
};
function parseKeysHookInput(keys, splitKey) {
  if (splitKey === void 0) {
    splitKey = ',';
  }
  if (typeof keys === 'string') {
    return keys.split(splitKey);
  }
  return keys;
}
function parseHotkey(hotkey, combinationKey) {
  if (combinationKey === void 0) {
    combinationKey = '+';
  }
  var keys = hotkey.toLocaleLowerCase().split(combinationKey).map(function (k) {
    return k.trim();
  }).map(function (k) {
    return mappedKeys[k] || k;
  });
  var modifiers = {
    alt: keys.includes('alt'),
    ctrl: keys.includes('ctrl'),
    shift: keys.includes('shift'),
    meta: keys.includes('meta'),
    mod: keys.includes('mod')
  };
  var singleCharKeys = keys.filter(function (k) {
    return !reservedModifierKeywords.includes(k);
  });
  return _extends({}, modifiers, {
    keys: singleCharKeys
  });
}

function maybePreventDefault(e, hotkey, preventDefault) {
  if (typeof preventDefault === 'function' && preventDefault(e, hotkey) || preventDefault === true) {
    e.preventDefault();
  }
}
function isHotkeyEnabled(e, hotkey, enabled) {
  if (typeof enabled === 'function') {
    return enabled(e, hotkey);
  }
  return enabled === true || enabled === undefined;
}
function isKeyboardEventTriggeredByInput(ev) {
  return isHotkeyEnabledOnTag(ev, ['input', 'textarea', 'select']);
}
function isHotkeyEnabledOnTag(_ref, enabledOnTags) {
  var target = _ref.target;
  if (enabledOnTags === void 0) {
    enabledOnTags = false;
  }
  var targetTagName = target && target.tagName;
  if (enabledOnTags instanceof Array) {
    return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(function (tag) {
      return tag.toLowerCase() === targetTagName.toLowerCase();
    }));
  }
  return Boolean(targetTagName && enabledOnTags && enabledOnTags === true);
}
function isScopeActive(activeScopes, scopes) {
  if (activeScopes.length === 0 && scopes) {
    console.warn('A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');
    return true;
  }
  if (!scopes) {
    return true;
  }
  return activeScopes.some(function (scope) {
    return scopes.includes(scope);
  }) || activeScopes.includes('*');
}
var isHotkeyMatchingKeyboardEvent = function isHotkeyMatchingKeyboardEvent(e, hotkey, pressedDownKeys) {
  var alt = hotkey.alt,
    ctrl = hotkey.ctrl,
    meta = hotkey.meta,
    mod = hotkey.mod,
    shift = hotkey.shift,
    keys = hotkey.keys;
  var altKey = e.altKey,
    ctrlKey = e.ctrlKey,
    metaKey = e.metaKey,
    shiftKey = e.shiftKey,
    pressedKeyUppercase = e.key,
    code = e.code;
  var keyCode = code.toLowerCase().replace('key', '');
  var pressedKey = pressedKeyUppercase.toLowerCase();
  if (altKey !== alt && pressedKey !== 'alt') {
    return false;
  }
  if (shiftKey !== shift && pressedKey !== 'shift') {
    return false;
  }
  // Mod is a special key name that is checking for meta on macOS and ctrl on other platforms
  if (mod) {
    if (!metaKey && !ctrlKey) {
      return false;
    }
  } else {
    if (metaKey !== meta && keyCode !== 'meta') {
      return false;
    }
    if (ctrlKey !== ctrl && keyCode !== 'ctrl') {
      return false;
    }
  }
  // All modifiers are correct, now check the key
  // If the key is set we check for the key
  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {
    return true;
  } else if (keys) {
    // Check if all keys are present in pressedDownKeys set
    return keys.every(function (key) {
      return pressedDownKeys.has(key);
    });
  } else if (!keys) {
    // If the key is not set, we only listen for modifiers, that check went alright, so we return true
    return true;
  }
  // There is nothing that matches.
  return false;
};

var BoundHotkeysProxyProvider = /*#__PURE__*/react.createContext(undefined);
var useBoundHotkeysProxy = function useBoundHotkeysProxy() {
  return react.useContext(BoundHotkeysProxyProvider);
};
function BoundHotkeysProxyProviderProvider(_ref) {
  var addHotkey = _ref.addHotkey,
    removeHotkey = _ref.removeHotkey,
    children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx(BoundHotkeysProxyProvider.Provider, {
    value: {
      addHotkey: addHotkey,
      removeHotkey: removeHotkey
    },
    children: children
  });
}

var HotkeysContext = /*#__PURE__*/react.createContext({
  hotkeys: [],
  enabledScopes: [],
  toggleScope: function toggleScope() {},
  enableScope: function enableScope() {},
  disableScope: function disableScope() {}
});
var useHotkeysContext = function useHotkeysContext() {
  return react.useContext(HotkeysContext);
};
var HotkeysProvider = function HotkeysProvider(_ref) {
  var _ref$initiallyActiveS = _ref.initiallyActiveScopes,
    initiallyActiveScopes = _ref$initiallyActiveS === void 0 ? ['*'] : _ref$initiallyActiveS,
    children = _ref.children;
  var _useState = react.useState((initiallyActiveScopes == null ? void 0 : initiallyActiveScopes.length) > 0 ? initiallyActiveScopes : ['*']),
    internalActiveScopes = _useState[0],
    setInternalActiveScopes = _useState[1];
  var _useState2 = react.useState([]),
    boundHotkeys = _useState2[0],
    setBoundHotkeys = _useState2[1];
  var isAllActive = react.useMemo(function () {
    return internalActiveScopes.includes('*');
  }, [internalActiveScopes]);
  var enableScope = function enableScope(scope) {
    if (isAllActive) {
      setInternalActiveScopes([scope]);
    } else {
      setInternalActiveScopes(Array.from(new Set([].concat(internalActiveScopes, [scope]))));
    }
  };
  var disableScope = function disableScope(scope) {
    var scopes = internalActiveScopes.filter(function (s) {
      return s !== scope;
    });
    if (scopes.length === 0) {
      setInternalActiveScopes(['*']);
    } else {
      setInternalActiveScopes(scopes);
    }
  };
  var toggleScope = function toggleScope(scope) {
    if (internalActiveScopes.includes(scope)) {
      disableScope(scope);
    } else {
      enableScope(scope);
    }
  };
  var addBoundHotkey = function addBoundHotkey(hotkey) {
    setBoundHotkeys([].concat(boundHotkeys, [hotkey]));
  };
  var removeBoundHotkey = function removeBoundHotkey(hotkey) {
    setBoundHotkeys(boundHotkeys.filter(function (h) {
      return h.keys !== hotkey.keys;
    }));
  };
  return /*#__PURE__*/jsxRuntime.jsx(HotkeysContext.Provider, {
    value: {
      enabledScopes: internalActiveScopes,
      hotkeys: boundHotkeys,
      enableScope: enableScope,
      disableScope: disableScope,
      toggleScope: toggleScope
    },
    children: /*#__PURE__*/jsxRuntime.jsx(BoundHotkeysProxyProviderProvider, {
      addHotkey: addBoundHotkey,
      removeHotkey: removeBoundHotkey,
      children: children
    })
  });
};

function deepEqual(x, y) {
  //@ts-ignore
  return x && y && typeof x === 'object' && typeof y === 'object'
  //@ts-ignore
  ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).reduce(function (isEqual, key) {
    return isEqual && deepEqual(x[key], y[key]);
  }, true) : x === y;
}

function useDeepEqualMemo(value) {
  var ref = react.useRef(undefined);
  if (!deepEqual(ref.current, value)) {
    ref.current = value;
  }
  return ref.current;
}

var stopPropagation = function stopPropagation(e) {
  e.stopPropagation();
  e.preventDefault();
  e.stopImmediatePropagation();
};
var useSafeLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
function useHotkeys(keys, callback, options, dependencies) {
  var ref = react.useRef(null);
  var _useRef = react.useRef(new Set()),
    pressedDownKeys = _useRef.current;
  var _options = !(options instanceof Array) ? options : !(dependencies instanceof Array) ? dependencies : undefined;
  var _deps = options instanceof Array ? options : dependencies instanceof Array ? dependencies : [];
  var cb = react.useCallback(callback, [].concat(_deps));
  var memoisedOptions = useDeepEqualMemo(_options);
  var _useHotkeysContext = useHotkeysContext(),
    enabledScopes = _useHotkeysContext.enabledScopes;
  var proxy = useBoundHotkeysProxy();
  useSafeLayoutEffect(function () {
    if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(enabledScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {
      return;
    }
    var listener = function listener(e) {
      var _e$target;
      if (isKeyboardEventTriggeredByInput(e) && !isHotkeyEnabledOnTag(e, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {
        return;
      }
      // TODO: SINCE THE EVENT IS NOW ATTACHED TO THE REF, THE ACTIVE ELEMENT CAN NEVER BE INSIDE THE REF. THE HOTKEY ONLY TRIGGERS IF THE
      // REF IS THE ACTIVE ELEMENT. THIS IS A PROBLEM SINCE FOCUSED SUB COMPONENTS WONT TRIGGER THE HOTKEY.
      if (ref.current !== null && document.activeElement !== ref.current && !ref.current.contains(document.activeElement)) {
        stopPropagation(e);
        return;
      }
      if ((_e$target = e.target) != null && _e$target.isContentEditable && !(memoisedOptions != null && memoisedOptions.enableOnContentEditable)) {
        return;
      }
      parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function (key) {
        var _hotkey$keys;
        var hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey);
        if (isHotkeyMatchingKeyboardEvent(e, hotkey, pressedDownKeys) || (_hotkey$keys = hotkey.keys) != null && _hotkey$keys.includes('*')) {
          maybePreventDefault(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);
          if (!isHotkeyEnabled(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {
            stopPropagation(e);
            return;
          }
          cb(e, hotkey);
        }
      });
    };
    var handleKeyDown = function handleKeyDown(event) {
      pressedDownKeys.add(event.key.toLowerCase());
      if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === undefined && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || memoisedOptions != null && memoisedOptions.keydown) {
        listener(event);
      }
    };
    var handleKeyUp = function handleKeyUp(event) {
      if (event.key.toLowerCase() !== 'meta') {
        pressedDownKeys["delete"](event.key.toLowerCase());
      } else {
        // On macOS pressing down the meta key prevents triggering the keyup event for any other key https://stackoverflow.com/a/57153300/735226.
        pressedDownKeys.clear();
      }
      if (memoisedOptions != null && memoisedOptions.keyup) {
        listener(event);
      }
    };
    // @ts-ignore
    (ref.current || document).addEventListener('keyup', handleKeyUp);
    // @ts-ignore
    (ref.current || document).addEventListener('keydown', handleKeyDown);
    if (proxy) {
      parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function (key) {
        return proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey));
      });
    }
    return function () {
      // @ts-ignore
      (ref.current || document).removeEventListener('keyup', handleKeyUp);
      // @ts-ignore
      (ref.current || document).removeEventListener('keydown', handleKeyDown);
      if (proxy) {
        parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function (key) {
          return proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey));
        });
      }
    };
  }, [keys, cb, memoisedOptions, enabledScopes]);
  return ref;
}

var currentlyPressedKeys = /*#__PURE__*/new Set();
function isHotkeyPressed(key, splitKey) {
  if (splitKey === void 0) {
    splitKey = ',';
  }
  var hotkeyArray = Array.isArray(key) ? key : key.split(splitKey);
  return hotkeyArray.every(function (hotkey) {
    var parsedHotkey = parseHotkey(hotkey);
    for (var _iterator = _createForOfIteratorHelperLoose(currentlyPressedKeys), _step; !(_step = _iterator()).done;) {
      var pressedHotkey = _step.value;
      if (deepEqual(parsedHotkey, pressedHotkey)) {
        return true;
      }
    }
  });
}
function pushToCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  hotkeyArray.forEach(function (hotkey) {
    return currentlyPressedKeys.add(parseHotkey(hotkey));
  });
}
function removeFromCurrentlyPressedKeys(key) {
  var hotkeyArray = Array.isArray(key) ? key : [key];
  hotkeyArray.forEach(function (hotkey) {
    var parsedHotkey = parseHotkey(hotkey);
    for (var _iterator2 = _createForOfIteratorHelperLoose(currentlyPressedKeys), _step2; !(_step2 = _iterator2()).done;) {
      var _pressedHotkey$keys;
      var pressedHotkey = _step2.value;
      if ((_pressedHotkey$keys = pressedHotkey.keys) != null && _pressedHotkey$keys.every(function (key) {
        var _parsedHotkey$keys;
        return (_parsedHotkey$keys = parsedHotkey.keys) == null ? void 0 : _parsedHotkey$keys.includes(key);
      })) {
        currentlyPressedKeys["delete"](pressedHotkey);
      }
    }
  });
}
(function () {
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', function () {
      document.addEventListener('keydown', function (e) {
        pushToCurrentlyPressedKeys(e.key);
      });
      document.addEventListener('keyup', function (e) {
        removeFromCurrentlyPressedKeys(e.key);
      });
    });
  }
})();

exports.HotkeysProvider = HotkeysProvider;
exports.isHotkeyPressed = isHotkeyPressed;
exports.useHotkeys = useHotkeys;
exports.useHotkeysContext = useHotkeysContext;
//# sourceMappingURL=react-hotkeys-hook.cjs.development.js.map
